import { useCallback, useEffect, useState } from "react";
import styled from "styled-components";

// parse img markdown. Generated by chatgpt
function parseMarkdownImage(markdownText: string) {
  // 使用正则表达式匹配 Markdown 图像语法
  const imageRegex = /!\[(.*?)\]\((.*?)\)/;
  const match = imageRegex.exec(markdownText);

  if (match) {
    const altText = match[1];
    const imageUrl = match[2];
    return { alt: altText, url: imageUrl };
  } else {
    return null; // 没有找到图像语法
  }
}


type TImage = {
  ok: "loading" | "loaded" | "failed";
  index: number;
  src: string;
  alt: string;
  width: number;
  height: number;
}

export function Images({ imgsmd }: {
  imgsmd: string[]
}) {
  const [imagesData, setImagesData] = useState<TImage[]>(Array(imgsmd.length).map((_, index) => {
    return { ok: "loading", index, src: "", width: 0, height: 0, alt: "" }
  }))

  useEffect(() => {
    async function loadImages() {
      const promises: Promise<TImage>[] = imgsmd.map(async (md, index) => {
        const parsed = parseMarkdownImage(md)
        if (!parsed) {
          return { ok: "failed", index, src: "", width: 0, height: 0, alt: "" } as TImage
        }

        const { url, alt } = parsed

        const image = new Image();
        const loadImage = new Promise((resolve, reject) => {
          image.onload = () => resolve(image);
          image.onerror = () => reject({ ok: "failed", index, src: "", width: 0, height: 0, alt })
          image.src = url;
        })

        let rejectObj;

        await loadImage.catch((reason) => { rejectObj = reason })
        if (rejectObj) {
          return rejectObj
        } else {
          return { ok: "loaded", index, src: url, width: image.width, height: image.height, alt } as TImage;
        }
      })

      try {
        const fetchData: TImage[] = await Promise.all(promises);
        setImagesData(fetchData);
      } catch (error) {
        console.error('Error loading images:', error);
      }
    }

    loadImages();

  }, [imgsmd])

  const find = useCallback((i: number) => {
    for (const info of imagesData) {
      if (info.index === i) return info
    }
    return undefined
  }, [imagesData])

  if (imgsmd.length === 0) return null

  if (imgsmd.length === 1) return render1(imagesData.length > 0 ? imagesData[0] : undefined)

  // 两图以上只考虑默认多列布局
  return <ImageGrid>
    {imagesData.map((_, i) => {
      return <ImageContainer key={i}>
        {/*eslint-disable-next-line @next/next/no-img-element*/} {/* eslint-disable-next-line jsx-a11y/alt-text */}
        <img loading="lazy" src={imagesData[i].ok === "loaded" ? imagesData[i].src : ""} alt={imagesData[i].ok} />
      </ImageContainer>
    })}
  </ImageGrid>
}

function render1(info: TImage | undefined) {
  return <ImageContainer style={{
    maxWidth: "100%",
    maxHeight: "326px",
    aspectRatio: info
      ? info.width / info.height > 2
        ? 2 : info.width / info.height < 0.75
          ? 0.75
          : info.width / info.height
      : 2,
  }}>
    {/*eslint-disable-next-line @next/next/no-img-element*/} {/* eslint-disable-next-line jsx-a11y/alt-text */}
    <img loading="lazy" src={info?.src} />
  </ImageContainer>
}

const ImageContainer = styled.div`
  border-radius: 0.5rem;
  background: ${p => p.theme.colors.bg2};
  position: relative;
  overflow: hidden;
  aspect-ratio: 1;
  cursor: zoom-in;

  & img {
    position: absolute;
    -o-object-fit: cover;
    object-fit: cover;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
  }

  & img:after {
    content: attr(alt);
    background: ${p => p.theme.colors.bg2};
    color: ${p => p.theme.colors.uiLineGray};
    font-weight: bold;
    display: block;
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
    text-align: left;
    padding: 1em;
    word-break: break-all;
  }
`

const ImageGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 5px;

  @media screen and (max-width: 580px) {
    grid-template-columns: repeat(3, 1fr);
  }

` 