import fs from "fs";
import path from "path";
import readline from "readline";
import { writeJson } from "../fs/fs";
import { INFOFILE, MemoInfo, MemoPost, MemoTag } from "./memos.common";

export const MEMOS_DIR = path.join(process.cwd(), 'source', 'memos')
const MEMO_CSR_DATA_DIR = path.join(process.cwd(), 'public', 'data', 'memos')
const NUM_PER_PAGE = 12

/**
 * memos database
 * 构造函数返回一个 memo_db 对象
 */
export const memo_db = await (async function () {

  /**
   * Exported properies
   */
  const names = await ((async () => {
    let fileNames = await fs.promises.readdir(MEMOS_DIR);
    return fileNames.filter(f => {
      return f.endsWith(".md")
    }).sort((a, b) => {
      return a < b ? 1 : -1 // Desc for latest first
    })
  })())
  const tags: MemoTag = new Map<string, string[]>();
  const memos: MemoPost[] = []

  /**
   * Get memos by page. SSR only
   * @param page number from 0
   */
  const atPage = function (page: number) {
    return memos.filter(m => {
      m.csrIndex[0] === page
    })
  }

  /**
   *   Core Initialize
   **/

  console.log("[memos.ts] parsing memos......")

  let csrPage = 0;
  let csrIndex = -1; // 由於是新建条目前更新状态，因此從-1開始

  for (const src_file of names) {

    // state
    let isFirstLine = true
    let isFrontMatter = false
    let currId = ""

    const fileStream = fs.createReadStream(path.join(MEMOS_DIR, src_file))
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    })

    for await (const line of rl) {
      if (line.startsWith("---") && isFirstLine) {
        if (isFrontMatter) { // front matter end
          isFrontMatter = false
          isFirstLine = false
          continue
        } else {
          isFrontMatter = true // front matter start
          continue
        }
      } else if( isFrontMatter ){
        continue; //ignore in front matter
      } else if (line.startsWith("## ")) {

        // 分析完整的 markdown
        // 更新tags
        if (memos.length > 0) {
          const text = memos[memos.length - 1].content

          const matches = extractTagsFromMarkdown(text)
          matches.map(t => {
            if (tags.has(t)) {
              tags.get(t)?.push(currId)
            } else {
              tags.set(t, [currId])
            }
          })

        }

        // 更新索引状态
        csrIndex += 1;
        if (csrIndex === 10) {
          csrPage += 1;
          csrIndex = 0;
        }

        currId = line.slice(3)

        // add new memo
        memos.push({
          id: currId,
          content: "",
          imgurls: [],
          sourceFile: src_file,
          csrIndex: [csrPage, csrIndex],
        })
      } else {

        // detect imgs
        const imgreg = /\!\[.*\]\(.+\)/g;
        const matches = line.match(imgreg);
        if (matches) {
          memos[memos.length - 1].imgurls.concat(matches)
        } else {

          // update memo content
          if (memos.length === 0) continue // 忽略 frontmatter 和 ## 之间的空行
          const m = memos[memos.length - 1]
          m.content += line + "\n"
        }
      }
    }

    rl.close()
    fileStream.close()
  }


  return {
    names,
    tags,
    memos,
    atPage,
  }

})()

/**
 * generated by chatgpt
 */
function extractTagsFromMarkdown(markdown: string) {
  const tagRegex = /#([^\s#]+)(?![^\[]*\])/g; // 正则表达式用于匹配标签

  const tags = [];
  let match;
  while ((match = tagRegex.exec(markdown)) !== null) {
    const tag = match[1];
    // 检查标签的长度是否不超过14
    if (tag.length <= 14) {
      // 检查标签是否在代码块中
      const codeBlockRegex = /```[\s\S]*?```/g;
      const codeBlocks = markdown.match(codeBlockRegex) || [];
      let isInsideCodeBlock = false;
      for (const codeBlock of codeBlocks) {
        if (codeBlock.includes(match[0])) {
          isInsideCodeBlock = true;
          break;
        }
      }

      // 检查标签是否在链接语法中
      const linkRegex = /\[([^\]]+)\]\([^\)]+\)/g;
      const links = markdown.match(linkRegex) || [];
      let isInsideLink = false;
      for (const link of links) {
        if (link.includes(match[0])) {
          isInsideLink = true;
          break;
        }
      }

      if (!isInsideCodeBlock && !isInsideLink) {
        tags.push(tag);
      }
    }
  }

  return tags;
}

export function writeMemoJson() {

  const groupByPage = new Map<number, MemoPost[]>()
  let maxpage = 0;

  memo_db.memos.forEach(m => {
    const p = m.csrIndex[0]
    if (groupByPage.has(p)) {
      groupByPage.get(p)?.push(m)
    } else {
      groupByPage.set(p, [m])
    }
    maxpage = p > maxpage ? p : maxpage;
  })

  groupByPage.forEach((memos, page) => {
    writeJson(path.join(MEMO_CSR_DATA_DIR, `${page}.json`), memos)
  })

  const info: MemoInfo = {
    pages: maxpage,
    fileMap: []
  }

  writeJson(path.join(MEMO_CSR_DATA_DIR, INFOFILE), info)
}